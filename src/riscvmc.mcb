import ./num_to_binary_array.js

function onload minecraft:onload {
    scoreboard objectives add riscvmc dummy
    scoreboard objectives add mcb.interal dummy

    scoreboard players set #n1 riscvmc -1
}

# mem structure:
# m (RAM, dict)
# pc (program counter, 32 bit length array)
# r_inst (running instruction, 32 bit length array)
# decode_map (dict, stores parts of r_inst)
# - CODECLASS (2 bit, should always be 0b11)
# - OPCODE (5 bit)
# - FUNCT3 (3 bit)
# - FUNCT7 (7 bit)
# - RD (5 bit)
# - RS1 (5 bit)
# - RS2 (5 bit)
# - IMMJ (21 bit)
# - IMMB (13 bit)
# - IMMI (12 bit)
# - IMMS (12 bit)
# - IMMU (32 bit)
# decode_map_processed (dict, stores processed type of instruction)
# - ...(see below)

# debug: print pc, reg, decode_map, decode_map_processed
function print_state {
    block { with storage riscvmc:memory
        $say pc: $(pc)
        $say regs: $(reg)
        $say "decode_map: $(decode_map)"
        $say "decode_map_processed: $(decode_map_processed)"
    }
}

# set running flag to 0 (false)
function stop_running {
    scoreboard players set #running riscvmc 0
}

# set running flag to 1 (true)
function set_running {
    scoreboard players set #running riscvmc 1
}

# reset pc to 0x80000000
# remove all registers and memory
function reset {
    data modify storage riscvmc:memory pc set value <% from_num(0x80000000, 32) %>
    function mem:remove_reg
    function mem:remove_memory
}

function pc_add_4 {
    data modify storage bitops:tmp a_digits set from storage riscvmc:memory pc
    data modify storage bitops:tmp b_digits set value <% from_num(4, 32) %>
    function bitops:add
    data modify storage riscvmc:memory pc set from storage bitops:tmp digits
}

# fetch instruction from memory[pc], store it in r_inst
function fetch_inst {
    data modify storage bitops:tmp digits set from storage riscvmc:memory pc
    data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>
    
    data modify storage riscvmc:memory r_inst set value <% from_num(0, 32) %>

    REPEAT (3, 0) as i {
        data modify storage mem:tmp addr set from storage bitops:tmp digits
        data modify storage bitops:tmp fetch_inst.digits set from storage bitops:tmp digits
        function mem:get

        REPEAT (0, 7) as j {
            data modify storage riscvmc:memory r_inst[<% i * 8 + j %>] set from storage mem:tmp data[<%j%>]
        }

        data modify storage bitops:tmp a_digits set from storage bitops:tmp fetch_inst.digits
        function bitops:add
    }
}

function reset_decode_map {
    data modify storage riscvmc:memory decode_map.CODECLASS set value <% from_num(0, 2) %>
    data modify storage riscvmc:memory decode_map.OPCODE set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.FUNCT3 set value <% from_num(0, 3) %>
    data modify storage riscvmc:memory decode_map.FUNCT7 set value <% from_num(0, 7) %>
    data modify storage riscvmc:memory decode_map.RD set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.RS1 set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.RS2 set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.IMMJ set value <% from_num(0, 21) %>
    data modify storage riscvmc:memory decode_map.IMMB set value <% from_num(0, 13) %>
    data modify storage riscvmc:memory decode_map.IMMI set value <% from_num(0, 12) %>
    data modify storage riscvmc:memory decode_map.IMMS set value <% from_num(0, 12) %>
    data modify storage riscvmc:memory decode_map.IMMU set value <% from_num(0, 32) %>

    data remove storage riscvmc:memory decode_map_processed
}

# decode instruction, process r_inst and store parts into decode_map
# and then read the decoded parts and decide its type, store it into decode_map_processed
function decode_inst {
    # process decode_map
    function *reset_decode_map

    # CODECLASS
    data modify storage riscvmc:memory decode_map.CODECLASS[0] set from storage riscvmc:memory r_inst[30]
    data modify storage riscvmc:memory decode_map.CODECLASS[1] set from storage riscvmc:memory r_inst[31]

    # OPCODE
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.OPCODE[<%i%>] set from storage riscvmc:memory r_inst[<% i + 25 %>]
    }

    # FUNCT3
    data modify storage riscvmc:memory decode_map.FUNCT3[0] set from storage riscvmc:memory r_inst[17]
    data modify storage riscvmc:memory decode_map.FUNCT3[1] set from storage riscvmc:memory r_inst[18]
    data modify storage riscvmc:memory decode_map.FUNCT3[2] set from storage riscvmc:memory r_inst[19]

    # FUNCT7
    REPEAT (0, 6) as i {
        data modify storage riscvmc:memory decode_map.FUNCT7[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # RD
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RD[<%i%>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }

    # RS1
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RS1[<%i%>] set from storage riscvmc:memory r_inst[<% i + 12 %>]
    }

    # RS2
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RS2[<%i%>] set from storage riscvmc:memory r_inst[<% i + 7 %>]
    }

    # IMMJ
    REPEAT (0, 9) as i {
        data modify storage riscvmc:memory decode_map.IMMJ[<% i + 10 %>] set from storage riscvmc:memory r_inst[<% i + 1 %>]
    }
    REPEAT (0, 7) as i {
        data modify storage riscvmc:memory decode_map.IMMJ[<% i + 1 %>] set from storage riscvmc:memory r_inst[<% i + 12 %>]
    }
    data modify storage riscvmc:memory decode_map.IMMJ[9] set from storage riscvmc:memory r_inst[11]
    data modify storage riscvmc:memory decode_map.IMMJ[0] set from storage riscvmc:memory r_inst[0]

    # IMMB
    REPEAT (0, 3) as i {
        data modify storage riscvmc:memory decode_map.IMMB[<% i + 8 %>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }
    REPEAT (0, 5) as i {
        data modify storage riscvmc:memory decode_map.IMMB[<% i + 2 %>] set from storage riscvmc:memory r_inst[<% i + 1 %>]
    }
    data modify storage riscvmc:memory decode_map.IMMB[1] set from storage riscvmc:memory r_inst[24]
    data modify storage riscvmc:memory decode_map.IMMB[0] set from storage riscvmc:memory r_inst[0]

    # IMMI
    REPEAT (0, 11) as i {
        data modify storage riscvmc:memory decode_map.IMMI[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # IMMS
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.IMMS[<% i + 7 %>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }
    REPEAT (0, 6) as i {
        data modify storage riscvmc:memory decode_map.IMMS[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # IMMU
    REPEAT (0, 19) as i {
        data modify storage riscvmc:memory decode_map.IMMU[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # classify
    data remove storage riscvmc:memory decode_map_processed

    # CODECLASS (true if 0b11, false otherwise)
    data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.CODECLASS
    data modify storage bitops:tmp d_digits set value [1b,1b]
    function bitops:equal_not_32
    data modify storage riscvmc:memory decode_map_processed.CODECLASS set value false
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.CODECLASS set value true

    # OPCODE:
    # LUI: 01101
    # AUIPC: 00101
    # JAL: 11011
    # JALR: 11001
    # BRANCH: 11000
    # OP_IMM: 00100
    # OP: 01100
    # LOAD: 00000
    # STORE: 01000
    # FENCE: 00011
    REPEAT ({LUI: "[0b,1b,1b,0b,1b]", AUIPC: "[0b,0b,1b,0b,1b]", JAL: "[1b,1b,0b,1b,1b]", JALR: "[1b,1b,0b,0b,1b]", BRANCH: "[1b,1b,0b,0b,0b]", OP_IMM: "[0b,0b,1b,0b,0b]", OP: "[0b,1b,1b,0b,0b]", LOAD: "[0b,0b,0b,0b,0b]", STORE: "[0b,1b,0b,0b,0b]", FENCE: "[0b,0b,0b,1b,1b]"}) as key, value {
        data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.OPCODE
        data modify storage bitops:tmp d_digits set value <%value%>
        function bitops:equal_not_32
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.OPCODE set value <%key%>
    }

    # FUNCT3_OP_IMM_OP
    # ADD: 000
    # SUB: (using FUNCT7)
    # SLL: 001
    # SRL: 101
    # SRA: (using FUNCT7)
    # SLT: 010
    # SLTU: 011
    # XOR: 100
    # OR: 110
    # AND: 111
    REPEAT ({ADD: "[0b,0b,0b]", SLL: "[0b,0b,1b]", SRL: "[1b,0b,1b]", SLT: "[0b,1b,0b]", SLTU: "[0b,1b,1b]", XOR: "[1b,0b,0b]", OR: "[1b,1b,0b]", AND: "[1b,1b,1b]"}) as key, value {
        data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.FUNCT3
        data modify storage bitops:tmp d_digits set value <%value%>
        function bitops:equal_not_32
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value <%key%>
    }

    # FUNCT3_BRANCH
    # BEQ: 000
    # BNE: 001
    # BLT: 100
    # BGE: 101
    # BLTU: 110
    # BGEU: 111
    REPEAT ({BEQ: "[0b,0b,0b]", BNE: "[0b,0b,1b]", BLT: "[1b,0b,0b]", BGE: "[1b,0b,1b]", BLTU: "[1b,1b,0b]", BGEU: "[1b,1b,1b]"}) as key, value {
        data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.FUNCT3
        data modify storage bitops:tmp d_digits set value <%value%>
        function bitops:equal_not_32
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_BRANCH set value <%key%>
    }

    # FUNCT3_LOAD_STORE
    # B: 000
    # H: 001
    # W: 010
    # BU 100
    # HU: 101
    REPEAT ({B: "[0b,0b,0b]", H: "[0b,0b,1b]", W: "[0b,1b,0b]", BU: "[1b,0b,0b]", HU: "[1b,0b,1b]"}) as key, value {
        data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.FUNCT3
        data modify storage bitops:tmp d_digits set value <%value%>
        function bitops:equal_not_32
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_LOAD_STORE set value <%key%>
    }

    # PROCESS FUNCT7
    # if decode_map.FUNCT7 == 0x20 and decode_map.OPCODE == PYRSISCV_OPCODE.OP
    # ADD -> SUB
    # SRL -> SRA
    data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.FUNCT7
    data modify storage bitops:tmp d_digits set value <% from_num(0b0100000, 7) %>
    function bitops:equal_not_32
    execute if score #flag bitops matches 1 run {
        execute if data storage riscvmc:memory {decode_map_processed: {OPCODE:"OP"}} run {
            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP:"ADD"}} run {
                data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value "SUB"
            }
            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP:"SRL"}} run {
                data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value "SRA"
            }
        }
    }

    # is EBREAK?
    data modify storage bitops:tmp c_digits set from storage riscvmc:memory r_inst
    data modify storage bitops:tmp d_digits set value <% from_num(0x00100073, 32) %>
    function bitops:equal_not_32
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.EBREAK set value true

    # is ECALL?
    data modify storage bitops:tmp c_digits set from storage riscvmc:memory r_inst
    data modify storage bitops:tmp d_digits set value <% from_num(0x00000073, 32) %>
    function bitops:equal_not_32
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.ECALL set value true
}

# process operator
# needs memory: op.a as first arg, op.b as another.
# both of these should be 32 bit length array
# result is stored in op.result, true or false.
function process_branch {
    execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BEQ"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:equal
        data modify storage riscvmc:memory op.result set value false
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BNE"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:equal
        data modify storage riscvmc:memory op.result set value true
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory op.result set value false
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BLT"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmps
        data modify storage riscvmc:memory op.result set value false
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BLTU"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmpu
        data modify storage riscvmc:memory op.result set value false
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BGE"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmps
        data modify storage riscvmc:memory op.result set value true
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value false
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BGEU"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmpu
        data modify storage riscvmc:memory op.result set value true
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value false
    } else run {
        say Invalid branch FUNCT3
        scoreboard players set #running riscvmc 0
    }
}

# result is stored in op.result, 32 bit length array.
function process_arithmetic {
    execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "ADD"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:add
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SUB"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:subtract
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "XOR"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:xor
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "OR"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:or
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "AND"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:and
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLT"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmps
        data modify storage riscvmc:memory op.result set value <% from_num(0, 32) %>
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value <% from_num(1, 32) %>
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLTU"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        data modify storage bitops:tmp b_digits set from storage riscvmc:memory op.b
        function bitops:cmpu
        data modify storage riscvmc:memory op.result set value <% from_num(0, 32) %>
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value <% from_num(1, 32) %>
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLL"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.b
        function bitops:extract_lowest_5_bits
        data modify storage bitops:tmp shift_bits set from storage bitops:tmp num
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        function bitops:shift_left
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SRA"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.b
        function bitops:extract_lowest_5_bits
        data modify storage bitops:tmp shift_bits set from storage bitops:tmp num
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        function bitops:arithmetic_shift_right
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SRL"}} run {
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.b
        function bitops:extract_lowest_5_bits
        data modify storage bitops:tmp shift_bits set from storage bitops:tmp num
        data modify storage bitops:tmp a_digits set from storage riscvmc:memory op.a
        function bitops:logical_shift_right
        data modify storage riscvmc:memory op.result set from storage bitops:tmp digits
    } else run {
        say Invalid OP FUNCT3
        scoreboard players set #running riscvmc 0
    }
}

# execute instruction
function execute_inst {
    execute if data storage riscvmc:memory {decode_map_processed: {CODECLASS: true}} run {
        execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "JAL"}} run {
            data modify storage bitops:tmp a_digits set from storage riscvmc:memory pc
            data modify storage bitops:tmp b_digits set value <% from_num(4, 32) %>
            function bitops:add
            data modify storage mem:tmp data set from storage bitops:tmp digits
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMJ
            function bitops:sign_extend_32
            data modify storage bitops:tmp a_digits set from storage bitops:tmp digits
            data modify storage bitops:tmp b_digits set from storage riscvmc:memory pc
            function bitops:add
            data modify storage riscvmc:memory pc set from storage bitops:tmp digits
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "JALR"}} run {
            data modify storage bitops:tmp a_digits set from storage riscvmc:memory pc
            data modify storage bitops:tmp b_digits set value <% from_num(4, 32) %>
            function bitops:add
            data modify storage bitops:tmp temp set from storage bitops:tmp digits

            data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMI
            function bitops:sign_extend_32
            data modify storage bitops:tmp a_digits set from storage bitops:tmp digits

            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage bitops:tmp b_digits set from storage mem:tmp data
            function bitops:add
            data modify storage bitops:tmp digits[31] set value 0b
            
            data modify storage riscvmc:memory pc set from storage bitops:tmp digits
            
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            data modify storage mem:tmp data set from storage bitops:tmp temp
            function mem:put_reg
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "BRANCH"}} run {
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage riscvmc:memory op.a set from storage mem:tmp data
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS2
            function mem:get_reg
            data modify storage riscvmc:memory op.b set from storage mem:tmp data
            function *process_branch
            execute if data storage riscvmc:memory {op: {result: true}} run {
                data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMB
                function bitops:sign_extend_32
                data modify storage bitops:tmp a_digits set from storage bitops:tmp digits
                data modify storage bitops:tmp b_digits set from storage riscvmc:memory pc
                function bitops:add
                data modify storage riscvmc:memory pc set from storage bitops:tmp digits
            } else run {
                function *pc_add_4
            }
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "OP_IMM"}} run {
            data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMI
            function bitops:sign_extend_32
            data modify storage riscvmc:memory op.b set from storage bitops:tmp digits

            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage riscvmc:memory op.a set from storage mem:tmp data

            function *process_arithmetic

            data modify storage mem:tmp data set from storage riscvmc:memory op.result
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "OP"}} run {
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage riscvmc:memory op.a set from storage mem:tmp data

            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS2
            function mem:get_reg
            data modify storage riscvmc:memory op.b set from storage mem:tmp data

            function *process_arithmetic

            data modify storage mem:tmp data set from storage riscvmc:memory op.result
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "LUI"}} run {
            data modify storage mem:tmp data set from storage riscvmc:memory decode_map.IMMU
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "AUIPC"}} run {
            data modify storage bitops:tmp a_digits set from storage riscvmc:memory pc
            data modify storage bitops:tmp b_digits set from storage riscvmc:memory decode_map.IMMU
            function bitops:add
            data modify storage mem:tmp data set from storage bitops:tmp digits
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "LOAD"}} run {
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage bitops:tmp a_digits set from storage mem:tmp data
            data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMI
            function bitops:sign_extend_32
            data modify storage bitops:tmp b_digits set from storage bitops:tmp digits
            function bitops:add
            data modify storage bitops:tmp load.temp set from storage bitops:tmp digits

            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "W"}} run {
                data modify storage bitops:tmp digits set from storage bitops:tmp load.temp
                data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                data modify storage riscvmc:memory load.data set value <% from_num(0, 32) %>

                REPEAT (3, 0) as i {
                    data modify storage mem:tmp addr set from storage bitops:tmp digits
                    data modify storage bitops:tmp load.temp set from storage bitops:tmp digits
                    function mem:get

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:memory load.data[<% i * 8 + j %>] set from storage mem:tmp data[<%j%>]
                    }

                    data modify storage bitops:tmp a_digits set from storage bitops:tmp load.temp
                    function bitops:add
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "H"}} run {
                data modify storage bitops:tmp digits set from storage bitops:tmp load.temp
                data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                data modify storage riscvmc:memory load.data set value <% from_num(0, 32) %>

                REPEAT (3, 2) as i {
                    data modify storage mem:tmp addr set from storage bitops:tmp digits
                    data modify storage bitops:tmp load.temp set from storage bitops:tmp digits
                    function mem:get

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:memory load.data[<% i * 8 + j %>] set from storage mem:tmp data[<%j%>]
                    }

                    data modify storage bitops:tmp a_digits set from storage bitops:tmp load.temp
                    function bitops:add
                }

                REPEAT (0, 15) as i {
                    data modify storage riscvmc:memory load.data[<%i%>] set from storage riscvmc:memory load.data[16]
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "HU"}} run {
                data modify storage bitops:tmp digits set from storage bitops:tmp load.temp
                data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                data modify storage riscvmc:memory load.data set value <% from_num(0, 32) %>

                REPEAT (3, 2) as i {
                    data modify storage mem:tmp addr set from storage bitops:tmp digits
                    data modify storage bitops:tmp load.temp set from storage bitops:tmp digits
                    function mem:get

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:memory load.data[<% i * 8 + j %>] set from storage mem:tmp data[<%j%>]
                    }

                    data modify storage bitops:tmp a_digits set from storage bitops:tmp load.temp
                    function bitops:add
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "B"}} run {
                data modify storage mem:tmp addr set from storage bitops:tmp load.temp
                function mem:get

                data modify storage riscvmc:memory load.data set value <% from_num(0, 32) %>

                REPEAT (0, 7) as i {
                    data modify storage riscvmc:memory load.data[<% i + 24 %>] set from storage mem:tmp data[<%i%>]
                }

                REPEAT (0, 23) as i {
                    data modify storage riscvmc:memory load.data[<% i %>] set from storage riscvmc:memory load.data[24]
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "BU"}} run {
                data modify storage mem:tmp addr set from storage bitops:tmp load.temp
                function mem:get

                data modify storage riscvmc:memory load.data set value <% from_num(0, 32) %>

                REPEAT (0, 7) as i {
                    data modify storage riscvmc:memory load.data[<% i + 24 %>] set from storage mem:tmp data[<%i%>]
                }
            } else run {
                say Invalid FUNCT3_LOAD_STORE
                scoreboard players set #running riscvmc 0
            }

            data modify storage mem:tmp data set from storage riscvmc:memory load.data
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RD
            function mem:put_reg

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "STORE"}} run {
            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS2
            function mem:get_reg
            data modify storage riscvmc:memory store.data set from storage mem:tmp data

            data modify storage mem:tmp id set from storage riscvmc:memory decode_map.RS1
            function mem:get_reg
            data modify storage bitops:tmp a_digits set from storage mem:tmp data
            data modify storage bitops:tmp c_digits set from storage riscvmc:memory decode_map.IMMS
            function bitops:sign_extend_32
            data modify storage bitops:tmp b_digits set from storage bitops:tmp digits
            function bitops:add
            data modify storage bitops:tmp store.temp set from storage bitops:tmp digits

            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "W"}} run {
                data modify storage bitops:tmp digits set from storage bitops:tmp store.temp
                data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                REPEAT (3, 0) as i {
                    data modify storage mem:tmp addr set from storage bitops:tmp digits
                    data modify storage bitops:tmp store.temp set from storage bitops:tmp digits

                    data modify storage mem:tmp data set value <% from_num(0, 8) %>

                    REPEAT (7, 0) as j {
                        data modify storage mem:tmp data[<%j%>] set from storage riscvmc:memory store.data[<% i * 8 + j %>]
                    }

                    function mem:put

                    data modify storage bitops:tmp a_digits set from storage bitops:tmp store.temp
                    function bitops:add
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "H"}} run {
                data modify storage bitops:tmp digits set from storage bitops:tmp store.temp
                data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                REPEAT (3, 2) as i {
                    data modify storage mem:tmp addr set from storage bitops:tmp digits
                    data modify storage bitops:tmp store.temp set from storage bitops:tmp digits

                    data modify storage mem:tmp data set value <% from_num(0, 8) %>

                    REPEAT (7, 0) as j {
                        data modify storage mem:tmp data[<%j%>] set from storage riscvmc:memory store.data[<% i * 8 + j %>]
                    }

                    function mem:put

                    data modify storage bitops:tmp a_digits set from storage bitops:tmp store.temp
                    function bitops:add
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "B"}} run {
                data modify storage mem:tmp addr set from storage bitops:tmp store.temp

                data modify storage mem:tmp data set value <% from_num(0, 8) %>

                REPEAT (0, 7) as i {
                    data modify storage mem:tmp data[<%i%>] set from storage riscvmc:memory store.data[<% i + 24 %>]
                }

                function mem:put
            } else run {
                say Invalid FUNCT3_LOAD_STORE
                scoreboard players set #running riscvmc 0
            }

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "FENCE"}} run {
            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {EBREAK: true}} run {
            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {ECALL: true}} run {
            # a7
            data modify storage bitops:tmp a_digits set from storage riscvmc:memory reg.10001
            function bitops:to_str

            REPEAT ({SYS_read: 63, SYS_write: 64, SYS_exit: 93}) as key, value {
                execute if data storage bitops:tmp {str: "<% from_num_to_binary_str(value, 32) %>"} run {
                    data modify storage bitops:tmp ecall.type set value "<% key %>"
                }
            }

            execute if data storage bitops:tmp {ecall: {type: "SYS_write"}} run {
                # a0
                data modify storage bitops:tmp ecall.fd set from storage riscvmc:memory reg.01010
                # a1
                data modify storage bitops:tmp ecall.buf set from storage riscvmc:memory reg.01011
                # a2
                data modify storage bitops:tmp ecall.len set from storage riscvmc:memory reg.01100

                data modify storage bitops:tmp a_digits set from storage bitops:tmp ecall.len
                function bitops:to_num
                data modify storage bitops:tmp temp_len set from storage bitops:tmp num

                data modify storage bitops:tmp a_digits set from storage bitops:tmp ecall.fd
                function bitops:to_str
                execute if data storage bitops:tmp {str: "<% from_num_to_binary_str(1, 32) %>"} run {
                    scoreboard players set #i riscvmc 1
                    data modify storage bitops:tmp digits set from storage bitops:tmp ecall.buf
                    data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                    block { with storage bitops:tmp
                        $execute if score #i riscvmc matches ..$(temp_len) run {
                            data modify storage mem:tmp addr set from storage bitops:tmp digits
                            function mem:get
                            data modify storage ascii:tmp digits set from storage mem:tmp data
                            function ascii:process_digits

                            data modify storage bitops:tmp a_digits set from storage mem:tmp addr
                            function bitops:add

                            scoreboard players add #i riscvmc 1
                            function ^1 with storage bitops:tmp
                        }
                    }

                    data modify storage riscvmc:memory reg.01010 set from storage bitops:tmp ecall.len
                } else run {
                    say Invalid file descriptor in write ecall, ignored
                    # scoreboard players set #running riscvmc 0
                }
            }  else execute if data storage bitops:tmp {ecall: {type: "SYS_read"}} run {
                # a0
                data modify storage bitops:tmp ecall.fd set from storage riscvmc:memory reg.01010
                # a1
                data modify storage bitops:tmp ecall.buf set from storage riscvmc:memory reg.01011
                # a2
                data modify storage bitops:tmp ecall.len set from storage riscvmc:memory reg.01100

                data modify storage bitops:tmp a_digits set from storage bitops:tmp ecall.len
                function bitops:to_num
                data modify storage bitops:tmp temp_len set from storage bitops:tmp num

                data modify storage bitops:tmp a_digits set from storage bitops:tmp ecall.fd
                function bitops:to_str
                execute if data storage bitops:tmp {str: "<% from_num_to_binary_str(0, 32) %>"} run {
                    scoreboard players set #i riscvmc 1
                    data modify storage bitops:tmp digits set from storage bitops:tmp ecall.buf
                    data modify storage bitops:tmp b_digits set value <% from_num(1, 32) %>

                    block { with storage bitops:tmp
                        $execute if score #i riscvmc matches 1..$(temp_len) run {
                            function ascii:get_digits

                            execute if data storage ascii:tmp digits run {
                                data modify storage mem:tmp addr set from storage bitops:tmp digits
                                data modify storage mem:tmp data set from storage ascii:tmp digits
                                function mem:put

                                data modify storage bitops:tmp a_digits set from storage mem:tmp addr
                                function bitops:add

                                scoreboard players add #i riscvmc 1
                                function ^1 with storage bitops:tmp
                            }
                        }
                    }

                    scoreboard players operation #i riscvmc += #n1 riscvmc
                    execute store result storage bitops:tmp int_num int 1 run scoreboard players get #i riscvmc
                    function bitops:from_int

                    data modify storage riscvmc:memory reg.01010 set from storage bitops:tmp digits
                } else run {
                    say Invalid file descriptor in read ecall, ignored
                    # scoreboard players set #running riscvmc 0
                }
            } else execute if data storage bitops:tmp {ecall: {type: "SYS_exit"}} run {
                data modify storage bitops:tmp ecall.status set from storage riscvmc:memory reg.01010
                data modify storage bitops:tmp a_digits set from storage bitops:tmp ecall.status
                function bitops:to_num
                block { with storage bitops:tmp
                    $say Exiting with code $(num)
                }
                scoreboard players set #running riscvmc 0
            } else run {
                say Invalid ecall number
                scoreboard players set #running riscvmc 0
            }

            function *pc_add_4
        }
    } else run {
        say Invalid code class
        scoreboard players set #running riscvmc 0
    }
}

function step {
    function *fetch_inst
    function *decode_inst
    function *execute_inst

    data modify storage riscvmc:debug pc set from storage riscvmc:memory pc
    data modify storage riscvmc:debug decode_map set from storage riscvmc:memory decode_map
    data modify storage riscvmc:debug decode_map_processed set from storage riscvmc:memory decode_map_processed
    data modify storage riscvmc:debug reg set from storage riscvmc:memory reg

    data modify storage bitops:tmp a_digits set from storage riscvmc:debug pc
    function bitops:to_hex_str
    data modify storage riscvmc:debug pc set from storage bitops:tmp str

    REPEAT (0, 31) as i {
        execute if data storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %> run {
            data modify storage bitops:tmp a_digits set from storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %>
            function bitops:to_hex_str
            data modify storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %> set from storage bitops:tmp str
        } else run {
            data modify storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %> set value "00000000"
        }
    }
}