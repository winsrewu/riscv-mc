import ./num_to_binary_array.js
import ./argument_parser.js
import ./bitopst.mcbt
import ./memt.mcbt

function onload minecraft:load {
    scoreboard objectives add riscvmc dummy
    scoreboard objectives add mcb.internal dummy

    data modify storage riscvmc:temp temp.CODECLASS set value [1b, 1b]

    scoreboard players set #n1 riscvmc -1
}

# mem structure:
# m (RAM, dict)
# pc (program counter, 32 bit length array)
# r_inst (running instruction, 32 bit length array)
# decode_map (dict, stores parts of r_inst)
# - CODECLASS (2 bit, should always be 0b11)
# - OPCODE (5 bit)
# - FUNCT3 (3 bit)
# - FUNCT7 (7 bit)
# - RD (5 bit)
# - RS1 (5 bit)
# - RS2 (5 bit)
# - IMMJ (21 bit)
# - IMMB (13 bit)
# - IMMI (12 bit)
# - IMMS (12 bit)
# - IMMU (32 bit)
# decode_map_processed (dict, stores processed type of instruction)
# - ...(see below)

# debug: print pc, reg, decode_map, decode_map_processed
function print_state {
    block { with storage riscvmc:memory
        $say pc: $(pc)
        $say regs: $(reg)
        $say "decode_map: $(decode_map)"
        $say "decode_map_processed: $(decode_map_processed)"
    }
}

# set running flag to 0 (false)
function stop_running {
    scoreboard players set #running riscvmc 0
}

# set running flag to 1 (true)
function set_running {
    scoreboard players set #running riscvmc 1
}

# reset pc to 0x0
# remove all registers and memory
function reset {
    data modify storage riscvmc:memory pc set value <% from_num(0x0, 32) %>
    function mem:remove_reg
    function mem:remove_memory

    # remove pregenerated decode_map
    data remove storage riscvmc:decode_map i
    data remove storage riscvmc:decode_map ip
}

function pc_add_4 {
    data modify storage riscvmc:memory pc set from storage riscvmc:temp temp.pc_a4
}

# fetch instruction from memory[pc], store it in r_inst
function fetch_inst {
    data modify storage riscvmc:temp temp.pc set from storage riscvmc:memory pc
    data modify storage riscvmc:memory r_inst set value <% from_num(0, 32) %>

    REPEAT (3, 0) as i {
        template get riscvmc:temp@temp.pc riscvmc:temp@temp.mem

        REPEAT (0, 7) as j {
            data modify storage riscvmc:memory r_inst[<% i * 8 + j %>] set from storage riscvmc:temp temp.mem[<%j%>]
        }

        template add_1 riscvmc:temp@temp.pc
    }

    data modify storage riscvmc:temp temp.pc_a4 set from storage riscvmc:temp temp.pc
}

function reset_decode_map {
    data modify storage riscvmc:memory decode_map.CODECLASS set value <% from_num(0, 2) %>
    data modify storage riscvmc:memory decode_map.OPCODE set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.FUNCT3 set value <% from_num(0, 3) %>
    data modify storage riscvmc:memory decode_map.FUNCT7 set value <% from_num(0, 7) %>
    data modify storage riscvmc:memory decode_map.RD set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.RS1 set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.RS2 set value <% from_num(0, 5) %>
    data modify storage riscvmc:memory decode_map.IMMJ set value <% from_num(0, 21) %>
    data modify storage riscvmc:memory decode_map.IMMB set value <% from_num(0, 13) %>
    data modify storage riscvmc:memory decode_map.IMMI set value <% from_num(0, 12) %>
    data modify storage riscvmc:memory decode_map.IMMS set value <% from_num(0, 12) %>
    data modify storage riscvmc:memory decode_map.IMMU set value <% from_num(0, 32) %>

    data remove storage riscvmc:memory decode_map_processed
}

# if cache hit, set from cache
# otherwise call _decode_inst
function decode_inst {
    # process decode_map
    function *reset_decode_map

    template to_str 32 riscvmc:memory@r_inst riscvmc:temp@temp.str
    block { with storage riscvmc:temp temp
        $execute if data storage riscvmc:decode_map i.$(str) run { with storage riscvmc:temp temp
            # hit
            $data modify storage riscvmc:memory decode_map_processed set from storage riscvmc:decode_map ip.$(str)
            $data modify storage riscvmc:memory decode_map set from storage riscvmc:decode_map i.$(str)
        } else run {
            # miss
            function *_decode_inst
        }
    }
}

# decode instruction, process r_inst and store parts into decode_map
# and then read the decoded parts and decide its type, store it into decode_map_processed
function _decode_inst {
    # CODECLASS
    data modify storage riscvmc:memory decode_map.CODECLASS[0] set from storage riscvmc:memory r_inst[30]
    data modify storage riscvmc:memory decode_map.CODECLASS[1] set from storage riscvmc:memory r_inst[31]

    # OPCODE
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.OPCODE[<%i%>] set from storage riscvmc:memory r_inst[<% i + 25 %>]
    }

    # FUNCT3
    data modify storage riscvmc:memory decode_map.FUNCT3[0] set from storage riscvmc:memory r_inst[17]
    data modify storage riscvmc:memory decode_map.FUNCT3[1] set from storage riscvmc:memory r_inst[18]
    data modify storage riscvmc:memory decode_map.FUNCT3[2] set from storage riscvmc:memory r_inst[19]

    # FUNCT7
    REPEAT (0, 6) as i {
        data modify storage riscvmc:memory decode_map.FUNCT7[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # RD
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RD[<%i%>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }

    # RS1
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RS1[<%i%>] set from storage riscvmc:memory r_inst[<% i + 12 %>]
    }

    # RS2
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.RS2[<%i%>] set from storage riscvmc:memory r_inst[<% i + 7 %>]
    }

    # IMMJ
    REPEAT (0, 9) as i {
        data modify storage riscvmc:memory decode_map.IMMJ[<% i + 10 %>] set from storage riscvmc:memory r_inst[<% i + 1 %>]
    }
    REPEAT (0, 7) as i {
        data modify storage riscvmc:memory decode_map.IMMJ[<% i + 1 %>] set from storage riscvmc:memory r_inst[<% i + 12 %>]
    }
    data modify storage riscvmc:memory decode_map.IMMJ[9] set from storage riscvmc:memory r_inst[11]
    data modify storage riscvmc:memory decode_map.IMMJ[0] set from storage riscvmc:memory r_inst[0]

    # IMMB
    REPEAT (0, 3) as i {
        data modify storage riscvmc:memory decode_map.IMMB[<% i + 8 %>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }
    REPEAT (0, 5) as i {
        data modify storage riscvmc:memory decode_map.IMMB[<% i + 2 %>] set from storage riscvmc:memory r_inst[<% i + 1 %>]
    }
    data modify storage riscvmc:memory decode_map.IMMB[1] set from storage riscvmc:memory r_inst[24]
    data modify storage riscvmc:memory decode_map.IMMB[0] set from storage riscvmc:memory r_inst[0]

    # IMMI
    REPEAT (0, 11) as i {
        data modify storage riscvmc:memory decode_map.IMMI[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # IMMS
    REPEAT (0, 4) as i {
        data modify storage riscvmc:memory decode_map.IMMS[<% i + 7 %>] set from storage riscvmc:memory r_inst[<% i + 20 %>]
    }
    REPEAT (0, 6) as i {
        data modify storage riscvmc:memory decode_map.IMMS[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # IMMU
    REPEAT (0, 19) as i {
        data modify storage riscvmc:memory decode_map.IMMU[<%i%>] set from storage riscvmc:memory r_inst[<%i%>]
    }

    # classify
    data remove storage riscvmc:memory decode_map_processed

    # CODECLASS (true if 0b11, false otherwise)
    template equal_not_32 riscvmc:memory@decode_map.CODECLASS riscvmc:temp@temp.CODECLASS
    data modify storage riscvmc:memory decode_map_processed.CODECLASS set value false
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.CODECLASS set value true

    # OPCODE:
    # LUI: 01101
    # AUIPC: 00101
    # JAL: 11011
    # JALR: 11001
    # BRANCH: 11000
    # OP_IMM: 00100
    # OP: 01100
    # LOAD: 00000
    # STORE: 01000
    # FENCE: 00011
    REPEAT ({LUI: "[0b,1b,1b,0b,1b]", AUIPC: "[0b,0b,1b,0b,1b]", JAL: "[1b,1b,0b,1b,1b]", JALR: "[1b,1b,0b,0b,1b]", BRANCH: "[1b,1b,0b,0b,0b]", OP_IMM: "[0b,0b,1b,0b,0b]", OP: "[0b,1b,1b,0b,0b]", LOAD: "[0b,0b,0b,0b,0b]", STORE: "[0b,1b,0b,0b,0b]", FENCE: "[0b,0b,0b,1b,1b]"}) as key, value {
        data modify storage riscvmc:temp temp.eq set value <%value%>
        template equal_not_32 riscvmc:temp@temp.eq riscvmc:memory@decode_map.OPCODE

        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.OPCODE set value <%key%>
    }

    # FUNCT3_OP_IMM_OP
    # ADD: 000
    # SUB: (using FUNCT7)
    # SLL: 001
    # SRL: 101
    # SRA: (using FUNCT7)
    # SLT: 010
    # SLTU: 011
    # XOR: 100
    # OR: 110
    # AND: 111
    REPEAT ({ADD: "[0b,0b,0b]", SLL: "[0b,0b,1b]", SRL: "[1b,0b,1b]", SLT: "[0b,1b,0b]", SLTU: "[0b,1b,1b]", XOR: "[1b,0b,0b]", OR: "[1b,1b,0b]", AND: "[1b,1b,1b]"}) as key, value {
        data modify storage riscvmc:temp temp.eq set value <% value %>
        template equal_not_32 riscvmc:temp@temp.eq riscvmc:memory@decode_map.FUNCT3
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value <%key%>
    }

    # FUNCT3_BRANCH
    # BEQ: 000
    # BNE: 001
    # BLT: 100
    # BGE: 101
    # BLTU: 110
    # BGEU: 111
    REPEAT ({BEQ: "[0b,0b,0b]", BNE: "[0b,0b,1b]", BLT: "[1b,0b,0b]", BGE: "[1b,0b,1b]", BLTU: "[1b,1b,0b]", BGEU: "[1b,1b,1b]"}) as key, value {
        data modify storage riscvmc:temp temp.eq set value <% value %>
        template equal_not_32 riscvmc:temp@temp.eq riscvmc:memory@decode_map.FUNCT3
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_BRANCH set value <%key%>
    }

    # FUNCT3_LOAD_STORE
    # B: 000
    # H: 001
    # W: 010
    # BU 100
    # HU: 101
    REPEAT ({B: "[0b,0b,0b]", H: "[0b,0b,1b]", W: "[0b,1b,0b]", BU: "[1b,0b,0b]", HU: "[1b,0b,1b]"}) as key, value {
        data modify storage riscvmc:temp temp.eq set value <% value %>
        template equal_not_32 riscvmc:temp@temp.eq riscvmc:memory@decode_map.FUNCT3
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.FUNCT3_LOAD_STORE set value <%key%>
    }

    # PROCESS FUNCT7
    # if decode_map.FUNCT7 == 0x20 and decode_map.OPCODE == PYRSISCV_OPCODE.OP
    # ADD -> SUB
    # SRL -> SRA
    data modify storage riscvmc:temp temp.eq set value <% from_num(0b0100000, 7) %>
    template equal_not_32 riscvmc:temp@temp.eq riscvmc:memory@decode_map.FUNCT7
    execute if score #flag bitops matches 1 run {
        execute if data storage riscvmc:memory {decode_map_processed: {OPCODE:"OP"}} run {
            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP:"ADD"}} run {
                data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value "SUB"
            }
            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP:"SRL"}} run {
                data modify storage riscvmc:memory decode_map_processed.FUNCT3_OP_IMM_OP set value "SRA"
            }
        }
    }

    # is EBREAK?
    data modify storage riscvmc:temp temp.eq set value <% from_num(0x00100073, 32) %>
    template equal riscvmc:temp@temp.eq riscvmc:memory@r_inst
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.EBREAK set value true

    # is ECALL?
    data modify storage riscvmc:temp temp.eq set value <% from_num(0x00000073, 32) %>
    template equal riscvmc:temp@temp.eq riscvmc:memory@r_inst
    execute if score #flag bitops matches 1 run data modify storage riscvmc:memory decode_map_processed.ECALL set value true
}

# process operator
# needs memory: op.a as first arg, op.b as another.
# both of these should be 32 bit length array
# result is stored in op.result, true or false.
function process_branch {
    execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BEQ"}} run {
        template equal riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value false
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BNE"}} run {
        template equal riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value false
        data modify storage riscvmc:memory op.result set value true
        execute if score #flag bitops matches 1 run data modify storage riscvmc:memory op.result set value false
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BLT"}} run {
        template cmps riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value false
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BLTU"}} run {
        template cmpu riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value false
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value true
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BGE"}} run {
        template cmps riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value true
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value false
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_BRANCH: "BGEU"}} run {
        template cmpu riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value true
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value false
    } else run {
        say Invalid branch FUNCT3
        scoreboard players set #running riscvmc 0
    }
}

# result is stored in op.result, 32 bit length array.
function process_arithmetic {
    execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "ADD"}} run {
        template add riscvmc:memory@op.a riscvmc:memory@op.b riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SUB"}} run {
        template subtract riscvmc:memory@op.a riscvmc:memory@op.b riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "XOR"}} run {
        template xor riscvmc:memory@op.a riscvmc:memory@op.b riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "OR"}} run {
        template or riscvmc:memory@op.a riscvmc:memory@op.b riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "AND"}} run {
        template and riscvmc:memory@op.a riscvmc:memory@op.b riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLT"}} run {
        template cmps riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value <% from_num(0, 32) %>
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value <% from_num(1, 32) %>
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLTU"}} run {
        template cmpu riscvmc:memory@op.a riscvmc:memory@op.b
        data modify storage riscvmc:memory op.result set value <% from_num(0, 32) %>
        execute if score #cmp bitops matches -1 run data modify storage riscvmc:memory op.result set value <% from_num(1, 32) %>
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SLL"}} run {
        template extract_lowest_5_bits riscvmc:memory@op.b riscvmc:temp@temp.num
        template shift_left riscvmc:memory@op.a riscvmc:temp@temp.num riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SRA"}} run {
        template extract_lowest_5_bits riscvmc:memory@op.b riscvmc:temp@temp.num
        template arithmetic_shift_right riscvmc:memory@op.a riscvmc:temp@temp.num riscvmc:memory@op.result
    } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_OP_IMM_OP: "SRL"}} run {
        template extract_lowest_5_bits riscvmc:memory@op.b riscvmc:temp@temp.num
        template logical_shift_right riscvmc:memory@op.a riscvmc:temp@temp.num riscvmc:memory@op.result
    } else run {
        say Invalid OP FUNCT3
        scoreboard players set #running riscvmc 0
    }
}

# execute instruction
function execute_inst {
    execute if data storage riscvmc:memory {decode_map_processed: {CODECLASS: true}} run {
        execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "JAL"}} run {
            data modify storage riscvmc:temp temp.pc set from storage riscvmc:temp temp.pc_a4
            template put_reg riscvmc:memory@decode_map.RD riscvmc:temp@temp.pc

            template sign_extend_32 riscvmc:memory@decode_map.IMMJ
            data modify storage riscvmc:temp temp.pc set from storage riscvmc:memory pc
            template add riscvmc:memory@decode_map.IMMJ riscvmc:temp@temp.pc riscvmc:memory@pc
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "JALR"}} run {
            data modify storage riscvmc:temp temp.pc set from storage riscvmc:temp temp.pc_a4

            template sign_extend_32 riscvmc:memory@decode_map.IMMI

            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:temp@temp.t
            template add riscvmc:temp@temp.t riscvmc:memory@decode_map.IMMI riscvmc:temp@temp.t2
            data modify storage riscvmc:temp temp.t2[31] set value 0b
            
            data modify storage riscvmc:memory pc set from storage riscvmc:temp temp.t2

            template put_reg riscvmc:memory@decode_map.RD riscvmc:temp@temp.pc
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "BRANCH"}} run {
            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:memory@op.a
            template get_reg riscvmc:memory@decode_map.RS2 riscvmc:memory@op.b

            function *process_branch
            execute if data storage riscvmc:memory {op: {result: true}} run {
                template sign_extend_32 riscvmc:memory@decode_map.IMMB
                data modify storage riscvmc:temp temp.pc set from storage riscvmc:memory pc
                template add riscvmc:memory@decode_map.IMMB riscvmc:temp@temp.pc riscvmc:memory@pc
            } else run {
                function *pc_add_4
            }
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "OP_IMM"}} run {
            template sign_extend_32 riscvmc:memory@decode_map.IMMI
            data modify storage riscvmc:memory op.b set from storage riscvmc:memory decode_map.IMMI

            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:memory@op.a

            function *process_arithmetic

            template put_reg riscvmc:memory@decode_map.RD riscvmc:memory@op.result

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "OP"}} run {
            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:memory@op.a
            template get_reg riscvmc:memory@decode_map.RS2 riscvmc:memory@op.b

            function *process_arithmetic

            template put_reg riscvmc:memory@decode_map.RD riscvmc:memory@op.result

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "LUI"}} run {
            template put_reg riscvmc:memory@decode_map.RD riscvmc:memory@decode_map.IMMU

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "AUIPC"}} run {
            template add riscvmc:memory@pc riscvmc:memory@decode_map.IMMU riscvmc:temp@temp.pc
            template put_reg riscvmc:memory@decode_map.RD riscvmc:temp@temp.pc

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "LOAD"}} run {
            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:temp@temp.t
            template sign_extend_32 riscvmc:memory@decode_map.IMMI
            template add riscvmc:temp@temp.t riscvmc:memory@decode_map.IMMI riscvmc:temp@temp.load

            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "W"}} run {
                data modify storage riscvmc:temp temp.load_data set value <% from_num(0, 32) %>

                REPEAT (3, 0) as i {
                    template get riscvmc:temp@temp.load riscvmc:temp@temp.load_data_raw

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:temp temp.load_data[<% i * 8 + j %>] set from storage riscvmc:temp temp.load_data_raw[<%j%>]
                    }

                    IF (i != 0) {
                        template add_1 riscvmc:temp@temp.load
                    }
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "H"}} run {
                data modify storage riscvmc:temp temp.load_data set value <% from_num(0, 32) %>

                REPEAT (3, 2) as i {
                    template get riscvmc:temp@temp.load riscvmc:temp@temp.load_data_raw

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:temp temp.load_data[<% i * 8 + j %>] set from storage riscvmc:temp temp.load_data_raw[<%j%>]
                    }

                    IF (i != 2) {
                        template add_1 riscvmc:temp@temp.load
                    }
                }

                REPEAT (0, 15) as i {
                    data modify storage riscvmc:temp temp.load_data[<%i%>] set from storage riscvmc:temp temp.load_data[16]
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "HU"}} run {
                data modify storage riscvmc:temp temp.load_data set value <% from_num(0, 32) %>

                REPEAT (3, 2) as i {
                    template get riscvmc:temp@temp.load riscvmc:temp@temp.load_data_raw

                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:temp temp.load_data[<% i * 8 + j %>] set from storage riscvmc:temp temp.load_data_raw[<%j%>]
                    }

                    IF (i != 2) {
                        template add_1 riscvmc:temp@temp.load
                    }
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "B"}} run {
                data modify storage riscvmc:temp temp.load_data set value <% from_num(0, 32) %>
                template get riscvmc:temp@temp.load riscvmc:temp@temp.load_data_raw

                REPEAT (0, 7) as i {
                    data modify storage riscvmc:temp temp.load_data[<% i + 24 %>] set from storage riscvmc:temp temp.load_data_raw[<%i%>]
                }

                REPEAT (0, 23) as i {
                    data modify storage riscvmc:temp temp.load_data[<% i %>] set from storage riscvmc:temp temp.load_data[24]
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "BU"}} run {
                data modify storage riscvmc:temp temp.load_data set value <% from_num(0, 32) %>
                template get riscvmc:temp@temp.load riscvmc:temp@temp.load_data_raw

                REPEAT (0, 7) as i {
                    data modify storage riscvmc:temp temp.load_data[<% i + 24 %>] set from storage riscvmc:temp temp.load_data_raw[<%i%>]
                }
            } else run {
                say Invalid FUNCT3_LOAD_STORE
                scoreboard players set #running riscvmc 0
            }

            template put_reg riscvmc:memory@decode_map.RD riscvmc:temp@temp.load_data

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "STORE"}} run {
            template get_reg riscvmc:memory@decode_map.RS2 riscvmc:temp@temp.store_data

            template get_reg riscvmc:memory@decode_map.RS1 riscvmc:temp@temp.t
            template sign_extend_32 riscvmc:memory@decode_map.IMMS
            template add riscvmc:temp@temp.t riscvmc:memory@decode_map.IMMS riscvmc:temp@temp.store

            execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "W"}} run {
                data modify storage riscvmc:temp temp.store_data_raw set value <% from_num(0, 8) %>

                REPEAT (3, 0) as i {
                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:temp temp.store_data_raw[<%j%>] set from storage riscvmc:temp temp.store_data[<% i * 8 + j %>]
                    }

                    template put riscvmc:temp@temp.store riscvmc:temp@temp.store_data_raw

                    template add_1 riscvmc:temp@temp.store
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "H"}} run {
                data modify storage riscvmc:temp temp.store_data_raw set value <% from_num(0, 8) %>

                REPEAT (3, 2) as i {
                    REPEAT (7, 0) as j {
                        data modify storage riscvmc:temp temp.store_data_raw[<%j%>] set from storage riscvmc:temp temp.store_data[<% i * 8 + j %>]
                    }

                    template put riscvmc:temp@temp.store riscvmc:temp@temp.store_data_raw
                    
                    template add_1 riscvmc:temp@temp.store
                }
            } else execute if data storage riscvmc:memory {decode_map_processed: {FUNCT3_LOAD_STORE: "B"}} run {
                data modify storage riscvmc:temp temp.store_data_raw set value <% from_num(0, 8) %>

                REPEAT (0, 7) as i {
                    data modify storage riscvmc:temp temp.store_data_raw[<%i%>] set from storage riscvmc:temp temp.store_data[<% i + 24 %>]
                }

                template put riscvmc:temp@temp.store riscvmc:temp@temp.store_data_raw
            } else run {
                say Invalid FUNCT3_LOAD_STORE
                scoreboard players set #running riscvmc 0
            }

            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {OPCODE: "FENCE"}} run {
            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {EBREAK: true}} run {
            function *pc_add_4
        } else execute if data storage riscvmc:memory {decode_map_processed: {ECALL: true}} run {
            # a7
            template to_str 32 riscvmc:memory@reg.10001 riscvmc:temp@temp.a7_str

            REPEAT ({SYS_read: 63, SYS_write: 64, SYS_exit: 93, SYS_run_command: 513, SYS_run_if: 514, SYS_place_block: 515}) as key, value {
                execute if data storage riscvmc:temp {temp: {a7_str: "<% from_num_to_binary_str(value, 32) %>"}} run {
                    data modify storage riscvmc:temp ecall.type set value "<% key %>"
                }
            }

            execute if data storage riscvmc:temp {ecall: {type: "SYS_write"}} run {
                # a0
                data modify storage riscvmc:temp ecall.fd set from storage riscvmc:memory reg.01010
                # a1
                data modify storage riscvmc:temp ecall.buf set from storage riscvmc:memory reg.01011
                # a2
                data modify storage riscvmc:temp ecall.len set from storage riscvmc:memory reg.01100

                template to_str 32 riscvmc:temp@ecall.fd riscvmc:temp@temp.a0_str
                template to_num unsigned riscvmc:temp@ecall.len
                scoreboard players operation #num riscvmc = #num bitops

                execute if data storage riscvmc:temp {temp: {a0_str: "<% from_num_to_binary_str(1, 32) %>"}} run {
                    scoreboard players set #i riscvmc 1

                    block {
                        execute if score #i riscvmc <= #num riscvmc run {
                            template get riscvmc:temp@ecall.buf ascii:tmp@digits
                            function ascii:process_digits

                            template add_1 riscvmc:temp@ecall.buf

                            scoreboard players add #i riscvmc 1
                            function ^1
                        }
                    }

                    data modify storage riscvmc:memory reg.01010 set from storage riscvmc:temp ecall.len
                } else run {
                    say Invalid file descriptor in write ecall, ignored
                    # scoreboard players set #running riscvmc 0
                }
            } else execute if data storage riscvmc:temp {ecall: {type: "SYS_read"}} run {
                # a0
                data modify storage riscvmc:temp ecall.fd set from storage riscvmc:memory reg.01010
                # a1
                data modify storage riscvmc:temp ecall.buf set from storage riscvmc:memory reg.01011
                # a2
                data modify storage riscvmc:temp ecall.len set from storage riscvmc:memory reg.01100

                template to_str 32 riscvmc:temp@ecall.fd riscvmc:temp@temp.a0_str
                template to_num unsigned riscvmc:temp@ecall.len
                scoreboard players operation #num riscvmc = #num bitops

                execute if data storage riscvmc:temp {temp: {a0_str: "<% from_num_to_binary_str(0, 32) %>"}} run {
                    scoreboard players set #i riscvmc 1

                    block {
                        execute if score #i riscvmc <= #num riscvmc run {
                            function ascii:get_digits

                            execute if data storage ascii:tmp digits run {
                                template put riscvmc:temp@ecall.buf ascii:tmp@digits

                                template add_1 riscvmc:temp@ecall.buf

                                scoreboard players add #i riscvmc 1
                                function ^1
                            }
                        }
                    }

                    scoreboard players operation #i riscvmc += #n1 riscvmc
                    execute store result storage riscvmc:temp ecall.ret_len int 1 run scoreboard players get #i riscvmc
                    template from_int riscvmc:temp@ecall.ret_len riscvmc:memory@reg.01010
                } else run {
                    say Invalid file descriptor in read ecall, ignored
                    # scoreboard players set #running riscvmc 0
                }
            } else execute if data storage riscvmc:temp {ecall: {type: "SYS_exit"}} run {
                data modify storage riscvmc:temp ecall.status set from storage riscvmc:memory reg.01010

                template to_num unsigned riscvmc:temp@ecall.status
                execute store result storage riscvmc:temp ecall.status_num int 1 run scoreboard players get #num bitops

                block { with storage riscvmc:temp ecall
                    $say Exiting with code $(status_num)
                }
                scoreboard players set #running riscvmc 0
            } else execute if data storage riscvmc:temp {ecall: {type: "SYS_run_command"}} run {
                # a0
                data modify storage riscvmc:temp ecall.buf set from storage riscvmc:memory reg.01010
                # a1
                data modify storage riscvmc:temp ecall.len set from storage riscvmc:memory reg.01011

                template to_num unsigned riscvmc:temp@ecall.len
                scoreboard players operation #num riscvmc = #num bitops

                scoreboard players set #i riscvmc 1

                function ascii:clear_inst_buffer

                block {
                    execute if score #i riscvmc <= #num riscvmc run {
                        template get riscvmc:temp@ecall.buf ascii:tmp@digits
                        function ascii:process_digits_inst

                        template add_1 riscvmc:temp@ecall.buf

                        scoreboard players add #i riscvmc 1
                        function ^1
                    }
                }

                block { with storage ascii:tmp
                    $$(inst_buffer)
                }

                function ascii:clear_inst_buffer
            } else execute if data storage riscvmc:temp {ecall: {type: "SYS_run_if"}} run {
                # a0
                data modify storage riscvmc:temp ecall.buf set from storage riscvmc:memory reg.01010
                # a1
                data modify storage riscvmc:temp ecall.len set from storage riscvmc:memory reg.01011

                template to_num unsigned riscvmc:temp@ecall.len
                scoreboard players operation #num riscvmc = #num bitops

                scoreboard players set #i riscvmc 1

                function ascii:clear_inst_buffer

                block {
                    execute if score #i riscvmc <= #num riscvmc run {
                        template get riscvmc:temp@ecall.buf ascii:tmp@digits
                        function ascii:process_digits_inst

                        template add_1 riscvmc:temp@ecall.buf

                        scoreboard players add #i riscvmc 1
                        function ^1
                    }
                }

                scoreboard players set #syscall_if_flag riscvmc 0

                block { with storage ascii:tmp
                    $execute if data storage riscvmc:if $(inst_buffer) run scoreboard players set #syscall_if_flag riscvmc 1
                }

                execute if score #syscall_if_flag riscvmc matches 1 run {
                    data modify storage riscvmc:memory reg.01010 set value <% from_num(1, 32) %>
                } else run {
                    data modify storage riscvmc:memory reg.01010 set value <% from_num(0, 32) %>
                }

                function ascii:clear_inst_buffer
            } else execute if data storage riscvmc:temp {ecall: {type: "SYS_place_block"}} run {
                # a0
                data modify storage riscvmc:temp ecall.xa set from storage riscvmc:memory reg.01010
                # a1
                data modify storage riscvmc:temp ecall.ya set from storage riscvmc:memory reg.01011
                # a2
                data modify storage riscvmc:temp ecall.za set from storage riscvmc:memory reg.01100
                # a3
                data modify storage riscvmc:temp ecall.block_id set from storage riscvmc:memory reg.01101

                template to_str 32 riscvmc:temp@ecall.block_id riscvmc:temp@temp.a3_str

                scoreboard players set #block_place_flag riscvmc 0

                REPEAT ({air: 0, stone: 1, dirt: 2, birch_wood: 3}) as key, value {
                    execute if data storage riscvmc:temp {temp: {a3_str: "<% from_num_to_binary_str(value, 32) %>"}} run {
                        data modify storage riscvmc:temp ecall.block set value "<% key %>"
                        scoreboard players set #block_place_flag riscvmc 1
                    }
                }

                execute if score #block_place_flag riscvmc matches 1 run {
                    template to_num unsigned riscvmc:temp@ecall.xa
                    execute store result storage riscvmc:temp ecall.x int 1 run scoreboard players get #num bitops

                    template to_num unsigned riscvmc:temp@ecall.ya
                    execute store result storage riscvmc:temp ecall.y int 1 run scoreboard players get #num bitops

                    template to_num unsigned riscvmc:temp@ecall.za
                    execute store result storage riscvmc:temp ecall.z int 1 run scoreboard players get #num bitops

                    block { with storage riscvmc:temp ecall
                        $setblock $(x) $(y) $(z) $(block)
                    }
                } else run {
                    say Invalid block ID in place block ecall
                    scoreboard players set #running riscvmc 0
                }                
            } else run {
                say Invalid ecall number
                scoreboard players set #running riscvmc 0
            }

            function *pc_add_4
        }
    } else run {
        say Invalid code class
        scoreboard players set #running riscvmc 0
    }
}

function step {
    function *fetch_inst
    function *decode_inst
    function *execute_inst
}

function debug_step {
    function *step

    data modify storage riscvmc:debug decode_map set from storage riscvmc:memory decode_map
    data modify storage riscvmc:debug decode_map_processed set from storage riscvmc:memory decode_map_processed
    data modify storage riscvmc:debug reg set from storage riscvmc:memory reg

    template to_hex_str riscvmc:memory@pc riscvmc:debug@pc

    REPEAT (0, 31) as i {
        execute if data storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %> run {
            template to_hex_str <% "riscvmc:memory@reg." + from_num_to_binary_str(i,5) %> <%"riscvmc:debug@reg." + from_num_to_binary_str(i,5) %>

            template get_array_length <% "riscvmc:memory@reg." + from_num_to_binary_str(i,5) %> riscvmc:debug@temp.reg_len
            execute unless data storage riscvmc:debug {temp: {reg_len: 32}} run {
                say Invalid length of register <% from_num_to_binary_str(i,5) %>
                scoreboard players set #running riscvmc 0
            }
        } else run {
            data modify storage riscvmc:debug reg.<% from_num_to_binary_str(i, 5) %> set value "00000000"
        }
    }
}