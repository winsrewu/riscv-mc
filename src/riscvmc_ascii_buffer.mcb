import ./ascii_to_binary.js
import ./num_to_binary_array.js
import ./argument_parser.js
import ./bitops_t.mcbt

# control characters are all ignored, except for \n and \t
# \n will flush the buffer and call 'say' command once
# \t will be replaced by 4 spaces
# char 32 - 126 will be put into the buffer
# char 127 will be ignored
# other chars will be replaced by '?'
# for instant buffer, \n will be ignored

function onload minecraft:load {
    data modify storage riscvmc_ascii_buffer:temp buffer set value ""
    data modify storage riscvmc_ascii_buffer:temp input_buffer set value ""
    data modify storage riscvmc_ascii_buffer:temp inst_buffer set value ""
    
    scoreboard objectives add ascii dummy
}

# tmp example:
# digits: [...] (8 bit length array)

# result:
# -
function process_digits {
    template left_pad_32 riscvmc_ascii_buffer:temp@digits
    template to_num unsigned riscvmc_ascii_buffer:temp@digits

    execute store result storage riscvmc_ascii_buffer:temp num int 1 run scoreboard players get #num bitops

    REPEAT (0, 255) as i {
        execute if data storage riscvmc_ascii_buffer:temp {num: <%i%>} run { with storage riscvmc_ascii_buffer:temp
            $data modify storage riscvmc_ascii_buffer:temp buffer set value "$(buffer)<% get_should_print(i) %>"
        }
    }
}


# tmp example:
# digits: [...] (8 bit length array)

# result:
# -
function process_digits_inst {
    template left_pad_32 riscvmc_ascii_buffer:temp@digits
    template to_num unsigned riscvmc_ascii_buffer:temp@digits

    execute store result storage riscvmc_ascii_buffer:temp num int 1 run scoreboard players get #num bitops

    REPEAT (0, 255) as i {
        execute if data storage riscvmc_ascii_buffer:temp {num: <%i%>} run { with storage riscvmc_ascii_buffer:temp
            $data modify storage riscvmc_ascii_buffer:temp inst_buffer set value "$(inst_buffer)<% get_should_print(i) %>"
        }
    }
}

function clear_inst_buffer {
    data modify storage riscvmc_ascii_buffer:temp inst_buffer set value ""
}

# tmp example:
# -

# result:
# digits: [...] (8 bit length array, if input_buffer is not empty)
# digits: None (if input_buffer is empty)
function get_digits {
    data remove storage riscvmc_ascii_buffer:temp digits

    execute unless data storage riscvmc_ascii_buffer:temp {input_buffer: ""} run {
        data modify storage riscvmc_ascii_buffer:temp ch set string storage riscvmc_ascii_buffer:temp input_buffer 0 1
        REPEAT (0, 255) as i {
            IF is_printable(i) && is_legal(i) {
                execute if data storage riscvmc_ascii_buffer:temp {ch: "<% get_corresponding_char(i) %>"} run {
                    data modify storage riscvmc_ascii_buffer:temp digits set value <% from_num(i, 8) %>
                }
            }
            IF is_printable(i) && !is_legal(i) {
                execute if data storage riscvmc_ascii_buffer:temp {ch: "\<% get_corresponding_char(i) %>"} run {
                    data modify storage riscvmc_ascii_buffer:temp digits set value <% from_num(i, 8) %>
                } 
            }
            IF i == 10 {
                execute if data storage riscvmc_ascii_buffer:temp {ch: "\n"} run {
                    data modify storage riscvmc_ascii_buffer:temp digits set value <% from_num(i, 8) %>
                }
            }
        }
        data modify storage riscvmc_ascii_buffer:temp input_buffer set string storage riscvmc_ascii_buffer:temp input_buffer 1
    }
}

# tmp example:
# -

# result:
# digits: 0 (if input_buffer is empty)
# digits: 1 (if input_buffer is not empty)
function is_input_buffer_empty {
    data modify storage riscvmc_ascii_buffer:temp digits set value 0
    execute unless data storage riscvmc_ascii_buffer:temp {input_buffer: ""} run {
        data modify storage riscvmc_ascii_buffer:temp digits set value 1
    }
}

function test {
    REPEAT (["H", "e", "l", "l", "o", ",", "W", "o", "r", "l", "d", "!", "\n"]) as i {
        say <% char_to_num(i) %>
        data modify storage riscvmc_ascii_buffer:temp digits set value <% from_num(char_to_num(i), 8) %>
        function *process_digits
    }
}